\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Aamina Hussain, hussaa54}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}

For the div method from the ComplexT class, I assumed that the complex numbers created were not of the form z = 0 + 0i, so as to avoid a dividing by zero error. For the sqrt method from the ComplexT class, I assumed that y (where z = x + yi) would not be zero. I raised an exception for the get\_phi method of the ComplexT class that returned "The phase is undefined" when the complex number was of the form z = 0 + 0i. Lastly, for the TriangleT class, I assumed that none of the inputs (for any method) would be negative numbers, since side lengths cannot be negative. I also assumed that for the perim and area methods, the triangles would be geometrically valid.

\section{Test Cases and Rationale} \label{Testing}

For most of the methods, I only had one test case. This is because they were simple methods, and as long as the output of the method is the same as the output of the calculator, the method would be correct. The methods I only had one test case for include real, imag, get\_r, conj, add, sub, recip, and div from the ComplexT class, and get sides, perim, and area from the TriangleT class. For the rest of the methods, I did the same number of test cases (or more) depending on how many possible outcomes there were for that method. For example, the equal method for both ComplexT and TriangleT have two outcomes: they can either be equal (True) or not equal (False). For this reason, I had two test cases for the equal method (ComplexT). For the TriangleT equal method, in addition to those two test cases, I had one where the sides were listed in a different order to make sure the method still outputted true regardless of what order the sides were listed in. The is\_valid method (TriangleT) also had three test cases since I had to test at least one valid triangle and one invalid triangle. I also only did one test case for sqrt (ComplexT), but afterward, I realized I should have done at lease two, since I had to test when y (where z = x + yi) was positive and when y was negative. 

\section{Results of Testing Partner's Code}

There were no failed test cases when I tested my partner's code using my test\_driver.py file. Although we were told it was likely that one or many of our test cases might fail due to ambiguity/abstraction in some parts of the assignment, I was not surprised that my partner's code passed my test cases; taking a closer look at our code, I realized that it was quite similar. I also believe another reason the code passes was because I tried to \emph{generalize} my test cases. However, I was not able to test the tri\_type method (TriangleT) on my partner's code. This is because I was unable to finish that specific method for my own assignment, and therefore did not have any test cases for it. 

\section{Critique of Given Design Specification}



\section{Answers to Questions}

\begin{enumerate}[(a)]

\item The real, imag, get\_r, get\_phi, conj, recip, and sqrt methods from ComplexT and the get\_sides, perim, area, is\_valid, and tri\_type methods from TriangleT are selectors (getters). Assuming that a mutator (setter) is a method that changes or updates the current state of an object, there are no mutator methods. This is because the methods that seem like they are changing the object (such as add from ComplexT) are not actually changing the current object. They are instead returning a newly created object.
\item State variables for ComplexT could be the real and imaginary parts of the complex number, or the magnitude and phase of the complex number. State variables for TriangleT could be the three sides of the triangle, or the three angles made by the adjacent sides of the triangle.
\item No, it would not make sense to add methods for less than and greater than. This is because you cannot linearly order complex numbers, since they exist in a two-dimensional plane.
\item Yes, it is possible that the integer inputs to the constructor for TriangleT will not form a geometrically valid triangle. I believe the class should check if the inputs create a valid triangle before creating the object. If it does not create a valid triangle, an exception should be raised and a suitable message should be outputted. This is provide immediate feedback to the user, so that no errors arise in the future and the performance of the other methods are not affected. Having each method (such as area) check if the triangle is valid before it runs requires an additional step and many compares. 
\item This is a bad idea; the user could input the incorrect type of triangle, which would result in them receiving incorrect information every time they want to access the type. There would be more room for error. Although calculating the type of triangle would take longer than just accessing the state variable, having incorrect data is not desirable. However, if it was guaranteed that the type inputted was correct, then it would be a good idea. Accessing the type of the triangle would be much quicker.
\item f
\item g
\item h
\item i

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\end {document}