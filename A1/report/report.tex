\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Aamina Hussain, hussaa54}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}

For the div method from the ComplexT class, I assumed that the complex numbers created were not of the form z = 0 + 0i, so as to avoid a dividing by zero error. For the sqrt method from the ComplexT class, I assumed that y (where z = x + yi) would not be zero. I raised an exception for the get\_phi method of the ComplexT class that returned "The phase is undefined" when the complex number was of the form z = 0 + 0i. Lastly, for the TriangleT class, I assumed that none of the inputs (for any method) would be negative numbers, since side lengths cannot be negative. I also assumed that for the perim and area methods, the triangles would be geometrically valid.

\section{Test Cases and Rationale} \label{Testing}

For most of the methods, I only had one test case. This is because they were simple methods, and as long as the output of the method is the same as the output of the calculator, the method would be correct. The methods I only had one test case for include real, imag, get\_r, conj, add, sub, recip, and div from the ComplexT class, and get sides, perim, and area from the TriangleT class. For the rest of the methods, I did the same number of test cases (or more) depending on how many possible outcomes there were for that method. For example, the equal method for both ComplexT and TriangleT have two outcomes: they can either be equal (True) or not equal (False). For this reason, I had two test cases for the equal method (ComplexT). For the TriangleT equal method, in addition to those two test cases, I had one where the sides were listed in a different order to make sure the method still outputted true regardless of what order the sides were listed in. The is\_valid method (TriangleT) also had three test cases since I had to test at least one valid triangle and one invalid triangle. I also only did one test case for sqrt (ComplexT), but afterward, I realized I should have done at lease two, since I had to test when y (where z = x + yi) was positive and when y was negative. 

\section{Results of Testing Partner's Code}

There were no failed test cases when I tested my partner's code using my test\_driver.py file. Although we were told it was likely that one or many of our test cases might fail due to ambiguity/abstraction in some parts of the assignment, I was not surprised that my partner's code passed my test cases; taking a closer look at our code, I realized that it was quite similar. I also believe another reason the code passes was because I tried to \emph{generalize} my test cases. However, I was not able to test the tri\_type method (TriangleT) on my partner's code. This is because I was unable to finish that specific method for my own assignment, and therefore did not have any test cases for it. 

\section{Critique of Given Design Specification}

The design specification had many strengths, including modularity and abstraction. Modularity because the methods were independent from each other, but were still related. The individual methods could be used in multiple scenarios, not only in the environment they were presented in. Abstraction because the specification only told us what the final result should be for each method, but not how we should implement it. This allowed us more degrees of freedom, and we were able to choose the most efficient way to implement the design.

Some disadvantages includes some unclear instructions. Nothing is specified for what we should do if the integer inputs for TriangleT are negative. It also does not specify what should be done for the methods get\_phi, div, and sqrt from ComplexT if the complex number is of the form z = 0 + 0i. What we should do for those cases is not specifically stated in the specification. The design specification was not the most formal, and for this reason there are ambiguities. To improve it I would suggest writing it more formally, or using more formal langauge.

\section{Answers to Questions}

\begin{enumerate}[(a)]

\item The real, imag, get\_r, get\_phi, conj, recip, and sqrt methods from ComplexT and the get\_sides, perim, area, is\_valid, and tri\_type methods from TriangleT are selectors (getters). Assuming that a mutator (setter) is a method that changes or updates the current state of an object, there are no mutator methods. This is because the methods that seem like they are changing the object (such as add from ComplexT) are not actually changing the current object. They are instead returning a newly created object.
\item State variables for ComplexT could be the real and imaginary parts of the complex number, or the magnitude and phase of the complex number. State variables for TriangleT could be the three sides of the triangle, or the three angles made by the adjacent sides of the triangle.
\item No, it would not make sense to add methods for less than and greater than. This is because you cannot linearly order complex numbers, since they exist in a two-dimensional plane.
\item Yes, it is possible that the integer inputs to the constructor for TriangleT will not form a geometrically valid triangle. I believe the class should check if the inputs create a valid triangle before creating the object. If it does not create a valid triangle, an exception should be raised and a suitable message should be outputted. This is provide immediate feedback to the user, so that no errors arise in the future and the performance of the other methods are not affected. Having each method (such as area) check if the triangle is valid before it runs requires an additional step and many compares. 
\item This is a bad idea; the user could input the incorrect type of triangle, which would result in them receiving incorrect information every time they want to access the type. There would be more room for error. Although calculating the type of triangle would take longer than just accessing the state variable, having incorrect data is not desirable. However, if it was guaranteed that the type inputted was correct, then it would be a good idea. Accessing the type of the triangle would be much quicker.
\item Poor performance usually leads to poor usability. For example, if the execution time of a simple command was more than even a minute, the user would be greatly inconvenienced. This is relevant because usability is the ease at which users can use the product, and it depends strongly on the preferences of the user. If the user is unsatisfied, that means the usability of the software product is insufficient.
\item It would not be necessary to "fake" a rational design process if whatever you are implementing is simple and straigtforward. However, the "Faked" Rational Design Process is how I usually approach any project, whether it seems simple or not. I figure out the problem, come up with certain requirements that need to be fulfilled in order to solve that problem, then make the code. Then, I test the code to ensure it solves the original problem and meets the requirements. If not, I start again by making some changes.
\item If a product is reusable, then it means that it can be used to create a new product. In order for the product to be reusable, it should be standardized and generic, meaning it can be used in multiple instances. A product is reliable if it usually does what it is supposed to do. A reusable product is likely to be a reliable product. This is because if it is reusable, then it must be generic, which means it is more likely to work in multiple situations and therefore be more reliable.
\item i

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\newpage

\section{Citations}

\begin{enumerate}

\item Wikipedia Complex Numbers page linked in the assignment specification document
\item SE 2AA4 lecture slides

\end{enumerate}

\end {document}	