7.a) yes, getters and setters should be unit tested. Unit testing getters is a good way to ensure that the values have been assigned to the correct corresponding state variable. Unit testing is necessary for the setters as well, for similar reasons. It is a good way to ensure that the state variable is actually being changed. Issues with setters and getters could result in issues with the rest of the code, since they are usually used when implementing other methods. It is important for every executable part of the code to be tested.

B) To test the getters that are functions, such as the unbalanced forces, 

C) 

D)
Close_enough(x_calc, y_true):
	- Out := very_close(x_calc, y_true)
	- Exception := not( |x_calc| = |y_true| ) => ValueError

Local function
Subtract : seq of R x seq of R --> seq of R
Subtract(x, y) \== [i : N|i in [0 .. |x| - 1] : |xi - yi\|]

Very_close : seq or R x seq of R --> Boolean
Very_close(x, y) \== 
\begin{table}[]
\begin{tabular}{lllll}
Routine name  & In                                                                                         & Out                         & Exceptions &  \\
close\_enough & x\_calc : seq of \textbackslash{}mathbb\{R\}, x\_true : seq of \textbackslash{}mathbb\{R\} & \textbackslash{}mathbb\{B\} &            &  \\
              &                                                                                            &                             &            &  \\
              &                                                                                            &                             &            & 
\end{tabular}
\end{table}

E) No, there should not be exceptions for negative coordinates. There were exceptions for shape dimensions and mass because you cannot have a negative side length of a shape for example. Coordinates, however, are arbitrary positions in space, and they are used to see the position of something with reference to the positions of everything else on the coordinate grid. For example, if shape1 was at (0, 0) and shape2 was at (0, -5), then shape2 would be 5 units below shape1. This shows that the positions are relative, and negative coordinates are not incorrect.

F) This invariant is always satisfied because in the specification there is an exception when you are creating a new TriangleT. If s and m are both not greater than zero, then the TriangleT constructor raises a ValueError exception. This means a new TriangleT will not even be created unless both s and m are greater than zero. Therefore, the invariant is always satisfied.

G) 
from math import sqrt
L = [sqrt(i) for i in range(5, 20) if i%2==1]


H)
def remove_uppercase_letters(word):
    split_words = [letter for letter in word if letter.islower()]
    word = ""
    for i in range(len(split_words)):
        word += split_words[i]
    return word



I)
