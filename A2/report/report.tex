\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Solution}
\author{Aamina Hussain}
\date{\today}

\begin {document}

\maketitle

This report discusses the testing of the \verb|CircleT|, \verb|TriangleT|, \verb|BodyT|, and \verb|Scene| classes written for Assignment 2. It also discusses the results
of running the same tests on the partner files. The assignment specifications
are then critiqued and the requested discussion questions are answered.

\section{Testing of the Original Program}

I simply tested the getters for CircleT.py, TriangleT.py, and BodyT.py using one test case each. This is because any boundary cases are included in the exceptions, and were therefore tested separately. Other than the exceptions, there were no condition statements to test. For CircleT.py, a ValueError exception was to be raised if the radius or mass of the circle was not greater than zero. test\_circle\_value\_error in my test\_driver.py file tested if the exception would be raised if the radius was zero or negative. test\_circle\_value\_error\_2 tested if the exception would be raised if the mass was zero or negative. test\_circle\_value\_error\_3 tested if the exception would be raised if the radius and the mass were zero or negative. The same went for TriangleT.py. A ValueError should have been raised if the side length or the mass was not above zero. test\_triangle\_value\_error tested if the exception would be raised if the side length was zero or negative. test\_triangle\_value\_error\_2 tested if the exception would be raised if the mass was zero or negative. test\_triangle\_value\_error\_3 tested if the exception would be raised if the radius and the mass were zero or negative. For BodyT.py, a ValueError should have been raised if the length of the three sequences given as inputs were not the same. This was tested using test\_body\_value\_error which tried to create an object with sequences of different lengths. Another ValueError should have been raised if any value in the mass sequence was not greater than zero. This was tested using test\_body\_value\_error\_2 which tried to create an object using a sequence for mass that had zeros or negative numbers. 

\section{Results of Testing Partner's Code}

There were no failed test cases when I tested my partner’s code using my test\_driver.py
file, and the same graphs were produced. Our code for CircleT.py and TriangleT.py were basically the same. For BodyT.py, I did not explicitly define the local functions. Instead I just implemented what the local function would do within the constructor. My partner, on the other hand, defined private local functions, and then called on those functions within the constructor method. While I used list comprehension and imported reduce from functools, my partner used for loops to create the desired sequences. For Scene.py, while I defined the local ode function inside of the sim function, my partner defined the ode function outside of sim, as a separate function. Although we implemented many functions differently, or did not implement them at all (I did not explicitly implement the local functions in BodyT.py), we still both passed the same test cases. This shows that there is still a level of abstraction even though we are following the MIS, since it tells us where to go, but not how to get there. I think one reason why there were no failed test cases is because we were all following the MIS given, unlike assignment one where there was no MIS and as a result there were more ambiguities.

\section{Critique of Given Design Specification}

The design specification had many strengths, including modularity and abstraction. Modularity because the methods were independent from each other, but were still related. Some of the individual methods could be used in multiple scenarios, not only in the environment they were presented in. Abstraction because the MIS only told us what the final result should be for each method, but not how we should implement it. This allowed us more
degrees of freedom, and we were able to choose the most efficient way to implement the design. Another strength was formality. Because we used the MIS for this assignment, the expectations were provided to us in a mathematical form. This allowed there to be no ambiguities, unlike assignment one. This formality allowed all exceptions to be specified, so I knew where to raise exceptions and where to make assumptions if necessary. The inputs, outputs, and their types were clear, along with which functions returned a value and which functions just made a transition. The modules were also all essential; none of the modules could have been done using a combination of the other modules. However, I feel as though the specification for the Plot.py did not properly specify some things. For example, if the image of the graphs was not shown in the A2 pdf, then I would not know that the three graphs should be stacked on top of each other, or displayed in a single window. I would also not know what the title or axes titles would be. I think in this case it is easier to explain what you want the graph to look like by showing an image, however, since we are using the MIS specification for this assignment, it should be consistent and use it for all of the modules we need to implement.

\section{Answers}

\begin{enumerate}[a)]

\item Yes, getters and setters should be unit tested. Unit testing getters is a good way to ensure that the values have been assigned to the correct corresponding state variable. Unit testing is necessary for the setters as well, for similar reasons. It is a good way to ensure that the state variable is actually being changed. Issues with setters and getters could result in issues with the rest of the code, since setters and getters are usually used when implementing other methods. It is important for every executable part of the code to be tested.

\item I would test the getters by creating a Scene object. Then I would print(object.get\_unbal\_forces()) and see if they return the same functions I set the unbalanced forces as. To test the setters, I would first check what the original function the unbalanced forces are for that object by print(object.get\_unbal\_forces()). Then I would set the forces to different functions (any other function) using object.set\_unbal\_forces(fxnA, fxnB). Then I would print(object.get\_unbal\_forces()) again to check if the function changed. This is what I would do if I did not have to perform an automated test.

\item Since matplotlib can generate and save a file for the plot you make, in order to perform an automated test, I could compare the two files. This can be done by reading the rows of pixels for each file, and seeing if they are equal. Two pixels are equal if they are the same color. If all the pixels for the two files are the same, then the two graphs are the same, and the test passes. If they are not the same, then the test fails.

\item Routine name - close\_enough\\
In - x\_calc : seq of $\mathbb{R}$, x\_true : seq of $\mathbb{R}$\\
Out - $\mathbb{B}$\\
\\
close\_enough(x\_calc, x\_true):
\begin{itemize}
	\item $out :=$ very\_close(subtract(x\_calc, x\_true), x\_true)
	\item exception: $\lnot(|x\_calc| = |x\_true|) \Rightarrow$ ValueError
\end{itemize}
Local Functions
\\
\\
subtract : seq of $\mathbb{R} \times$ seq of $\mathbb{R} \Rightarrow$ seq of $\mathbb{R}$\\
subtract(x, y) $\equiv [i : \mathbb{N}|i \in [0..|x|-1] : x_i-y_i]$
\\
\\
abs : seq of $\mathbb{R} \Rightarrow$ seq of $\mathbb{R}$\\
abs(x) $\equiv [i : \mathbb{N}|i \in [0..|x|-1] : |x_i|]$
\\
\\
max: seq of $\mathbb{R} \Rightarrow \mathbb{R}$\\
max(x) $\equiv$ the largest value in the sequence
\\
\\
very\_close : seq of $\mathbb{R} \times$ seq of $\mathbb{R} \Rightarrow \mathbb{B}$\\
very\_close(x, y) $\equiv max(abs(x))/max(abs(y)) < \epsilon$


\item No, there should not be exceptions for negative coordinates. There were exceptions for shape dimensions and mass because you cannot have a negative side length of a shape for example. Coordinates, however, are arbitrary positions in space, and they are used to see the position of something with reference to the positions of everything else on the coordinate grid. For example, if shape A was at (0, 0) and shape B was at (0, -5), then shape B would be 5 units below shape A. This shows that the positions are relative, and negative coordinates are not incorrect.

\item This invariant is always satisfied because in the specification there is an exception when you are creating a new TriangleT. If s and m are both not greater than zero, then the TriangleT constructor raises a ValueError exception. This means a new TriangleT will not even be created unless both s and m are greater than zero. Therefore, the invariant is always satisfied.

\item \begin{lstlisting}
from math import sqrt
question_g = [sqrt(i) for i in range(5, 20) if i%2 == 1]
\end{lstlisting}

\item \begin{lstlisting}
def remove_uppercase_letters(word):
  split_words = [letter for letter in word if letter.islower()]
  word = ""
  for i in range(len(split_words)):
    word += split_words[i]
  return word
\end{lstlisting}

\item Abstraction and generality are related by the fact that abstraction can be used to create a more general solution. A design is abstract if it focuses on what is important and disregards anything irrelevant. For example, it could tell you what the final outcome must be without telling you how you must produce that outcome. A design that is general allows you to use that design for multiple purposes. A design is generalized by using abstraction since the higher level of abstraction means more degrees of freedom, and these degrees of freedom allow the design to be generalized.

\item A module that is used by many other modules is a better scenario. This means that module is portable, and can be used in different environments. It also means it is maintainable, since if you modify that single module, it will automatically modify the other modules that use it. In the other scenario, where one module uses many modules, is not desirable because the module is highly coupled. Since the module depends on many other modules, it has to wait for all the other modules to be completed before it can be used or tested.

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for Shape.py}

\noindent \lstinputlisting{../src/Shape.py}

\newpage

\section{Code for CircleT.py}

\noindent \lstinputlisting{../src/CircleT.py}

\newpage

\section{Code for TriangleT.py}

\noindent \lstinputlisting{../src/TriangleT.py}

\newpage

\section{Code for BodyT.py}

\noindent \lstinputlisting{../src/BodyT.py}

\newpage

\section{Code for Scene.py}

\noindent \lstinputlisting{../src/Scene.py}

\newpage

\section{Code for Plot.py}

\noindent \lstinputlisting{../src/Plot.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's CircleT.py}

\noindent \lstinputlisting{../partner/CircleT.py}

\newpage

\section{Code for Partner's TriangleT.py}

\noindent \lstinputlisting{../partner/TriangleT.py}

\newpage

\section{Code for Partner's BodyT.py}

\noindent \lstinputlisting{../partner/BodyT.py}

\newpage

\section{Code for Partner's Scene.py}

\noindent \lstinputlisting{../partner/Scene.py}

\newpage

\end {document}
